# Auto-translation Architecture (Gemini)

## Goals
- Заполнять недостающие тексты UI на клиенте, когда статического файла нет или он пуст.
- Кэшировать сгенерированные переводы локально, чтобы не обращаться к Gemini повторно при каждом старте.
- Гарантировать целостность структуры: если перевод не соответствует английскому шаблону — откатываемся на fallback (EN).

## Поток
1. **Определение языка**
   - На старте берём `LanguageCode` из профиля.
   - Проверяем против whitelist `SUPPORTED_LANGS = ['en','de','ru','fr','es','it','pt','pl','zh','ja','ar']`. Нет в списке — сразу fallback `en`.
2. **Статический бандл**
   - Пытаемся загрузить `src/i18n/{lang}.json`.
   - Если значения заполнены — используем и завершаем цепочку.
3. **Локальный кэш Gemini**
   - IndexedDB (`idb`) с хранилищем `ai-locales`.
   - Ключ = `${lang}@v${schemaVersion}`, значение — JSON переводов.
   - Найден и валиден по шаблону — используем без запроса к AI.
4. **Запрос к Gemini**
   - Формируем промпт: отправляем `en.json` (или часть) + инструкции «переведи, сохрани структуру, верни JSON».
   - Ключ API берём из `.env.local` (`VITE_GEMINI_API_KEY`).
   - Запрос `POST https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent` (как в текущей интеграции), без прокси.
5. **Валидация ответа**
   - Проверяем, что пришёл JSON и все ключи строковые.
   - Сверяем структуру с английским шаблоном (рекурсивно).
   - Отсутствует ключ или нарушено форматирование — логируем и возвращаем fallback EN.
6. **Сохранение**
   - Прошёл валидацию → сохраняем в IndexedDB и, при необходимости, оставляем маркер в LocalStorage для отладки.
   - Подключаем bundle в i18next через `i18next.addResourceBundle(lang, 'translation', data, true, true)`.
7. **UI-состояния**
   - Пока идёт запрос: показываем скелетон с этапами («Подготовка интерфейса…», «Загрузка переводов…», «Почти готово…»).
   - Ошибка/таймаут — уведомление + откат на английский.

## Схема версионирования
- Вводим `LOCALE_SCHEMA_VERSION = 1`. Меняем `en.json` → увеличиваем версию.
- Несовпадение версии в IndexedDB → очищаем запись и перегенерируем перевод.

## API-клиент
- Обёртка `geminiTranslate(locale: LanguageCode, template: Record<string, unknown>): Promise<Record<string, string>>`.
- Обрабатываем 429/5xx ретраями (до 2 попыток), затем fallback.
- Таймаут запроса 15 секунд.
- Промпт фиксирует требования: «переводи кратко», «сохраняй плейсхолдеры `{{name}}`», «не переводить URL и названия брендов».

## Безопасность
- В Gemini отправляем только статический шаблон из репозитория, без пользовательских данных.
- Ключи лежат в `.env.local`, не попадают в git.
- Не дёргаем Gemini чаще одного раза на язык за сессию (in-memory guard).

## Валидация структуры
- Утилита `validateLocaleShape(base, candidate)` сравнивает ключи и допускает пустые строки.
- Пустая строка в статике = «нужно заполнить перевод».
- Отдельно проверяем плейсхолдеры `{{...}}` — они должны сохраниться.

## Точки интеграции
- `languageService.loadTranslations` (будущий модуль):
  1. Получаем английский шаблон.
  2. Пробуем статический JSON.
  3. Если нет данных — проверяем IndexedDB.
  4. Пусто → запрашиваем Gemini, валидируем, сохраняем, возвращаем.
- `LanguageProvider`: следит за `profile.ui`, переключает язык и инициирует загрузку.
- Отдельный лог по этапам через `console.info`.

## Тестирование
- Юнит-тесты на `validateLocaleShape` и проверку плейсхолдеров.
- Интеграционный мок Gemini (возвращает шаблон) для happy-path.
- E2E: переключение на язык без статического файла → скелетон → локализованный UI.

## Открытые вопросы
- Нужна ли подстраховка в LocalStorage помимо IndexedDB?
- Ограничивать ли размер ответа Gemini (например, 32k символов) — можно добавить проверку.
